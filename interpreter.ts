import { Client, CacheType, ChatInputCommandInteraction, ChannelType, TextBasedChannel} from "discord.js"
import { Connection } from "mysql"
import { DetermineInterpreter } from "./interpreters/select_interpreter"
import { ActiveGame } from "./models/activegame"
import { Character } from "./models/character"
import { Initiative } from "./models/initiative"
import { Inventory } from "./models/inventory"
import { UtilityFunctions }  from './utility'

module CommandInterpreter{
    /**
     * Replies with return of interpretHelper to original slash command
     * @param interaction - Interaction to be passed to interpretHelper
     * @param gamedb - Database connection to be passed to interpretHelper
     * @param guildID - GuildID (Server ID) to be passed to interpretHelper
     * @param client - Discord Client to be passed to interpretHelper
     */
    export async function interpret(interaction: ChatInputCommandInteraction<CacheType>,
                                            gamedb: Connection,
                                            guildID: string,
                                            client: Client<boolean>) : Promise<void> {
        interaction.reply({
            content: await interpretHelper(interaction, gamedb, guildID, client)
        })
    }

    /**
     * Interprets slash commands for characters, games, rolls, and items
     * @param interaction - Interaction generated by user's initial slash command
     * @param gamedb - Database connection where game data is stored
     * @param guildID - Current Discord Server ID
     * @param client - Discord Client generated for current instances
     */
    export async function interpretHelper(interaction: ChatInputCommandInteraction<CacheType>, 
                                            gamedb: Connection,
                                            guildID: string,
                                            client: Client<boolean>) : Promise<string> {
        ActiveGame.createTable(gamedb)
    
        const { commandName, options } = interaction
        const userId = interaction.user.id

        const gameName = UtilityFunctions.formatNullString(options.getString('game-name'), / /g, '_')
        
        const activeGame = await ActiveGame.getCurrentGame(gamedb, 'GamesDB', guildID, gameName)
        const tableNameBase = `${guildID}_${activeGame?.gameName == null? gameName : activeGame?.gameName}`;
        const customInterp = DetermineInterpreter.select(activeGame?.gameType, gamedb, tableNameBase)

        // Creates new game & adds it to ActiveGame table, along with creating associated tables needed to maintain it
        if(commandName === 'create-game'){

            const gameType = UtilityFunctions.formatNullString(options.getString('game-type'))

            let DM = options.getUser('dm-name')?.id
    
            DM ??= userId
    
            const newGame = new ActiveGame(guildID, gameName, gameType, DM, true, '', 0, 0, false, null, null)
    
            newGame.addToTable(gamedb)
            
            let additionalStats = Character.parseColumns(
                UtilityFunctions.formatNullString(options.getString('additional-stats')))
            
            if(additionalStats == undefined){
                return 'Issue parsing additional columns.'
            }

            customInterp?.initializeTables()
    
            Character.createTable(gamedb, tableNameBase, additionalStats)
            Inventory.createTable(gamedb, tableNameBase)

            return `The game **\"${gameName}\"** has been successfully created.`
        } 
        // Adds character to character table
        else if(commandName === 'add-chr'){
    
            const charName = UtilityFunctions.formatString(options.getString('chr-name', true))
            const chrUser = options.getUser('chr-owner')
            const stats = UtilityFunctions.formatNullString(options.getString('additional-stats'))
            const chrId = chrUser == null ? userId : String(chrUser.id)

            let additionalStats = Character.parseColumns(stats)
            if(additionalStats == undefined){
                return 'Issue parsing additional columns.'
            }
    
            let newChar = new Character(charName, 
                                        UtilityFunctions.getEmojiID(
                                            UtilityFunctions.formatNullString(
                                                options.getString('emote'))),
                                        UtilityFunctions.formatNullString(options.getString('pronouns')),
                                        chrId,
                                        options.getNumber('health'),
                                        0,
                                        additionalStats);
                                        
            if(!(await newChar.addToTable(gamedb, tableNameBase))){
                return `Error: Duplicate character **\"${charName}\"**.`
            }
            
            return `The character **\"${charName}\"** has been successfully created.`
        }
        // Removes character from character table
        else if(commandName === 'rmv-chr'){
            const charName = UtilityFunctions.formatString(options.getString('chr-name', true))
            const tbdChar = await customInterp?.getCharacter(charName)
    
            tbdChar?.removeFromTable(gamedb, tableNameBase)    
    
            return `The character **\"${charName}\"** has been successfully deleted.`
        } 
        // Views character from character table
        else if(commandName === 'view-chr'){
            const charName = UtilityFunctions.formatString(options.getString('chr-name', true))
            const char = await customInterp?.getCharacter(charName)
    
            if(char == null){
                return `Finding character **\"${charName}\"** was unsuccessful.`
            }
    
            interaction.channel?.send({embeds : [char.buildViewEmbed(interaction.user, interaction.guild)] });
    
            return `The character **\"${charName}\"** has been successfully viewed.`
        } 
        // Parses roll from user, generates it, and returns result
        else if(commandName === 'roll'){
            const query = options.getString('query', true)
            let identifier = options.getString('identifier')

            identifier ??= 'Result'
            identifier += ': '
    
            const result = UtilityFunctions.parseRoll(query)
            
            return `${interaction.user} :game_die:\n**${identifier}** ${result?.[0]}\n**Total:** ${result?.[1]}`
        } 
        // Changes any stat for a character
        else if(commandName === 'change-stat'){
            const charName = UtilityFunctions.formatString(options.getString('chr-name', true))
            const statName = UtilityFunctions.formatString(options.getString('stat-name', true))
            const statValue = UtilityFunctions.formatString(options.getString('stat-value', true))
            
            let tbdChar = new Character(charName, null, null, '', -1, -1, []);
            if(!tbdChar.updateStat(gamedb, tableNameBase, statName, statValue)){
                return 'Cannot update the Name column of a character. ' +
                        'Instead please remove the character and replace them with a new one.'
            }

            return `The character stat **\"${statName}\"** for **\"${charName}\"** has successfully been changed to **\"${statValue}\"**.`
        } 
        // Changes DM for currently active game
        else if(commandName === 'set-dm'){
            const newDM = options.getUser('newdm-name', true)
    
            if(activeGame == null){
                return 'Issue retrieving active game.'
            }

            const guild = client.guilds.cache.get(guildID)
            const oldDM = guild?.members.cache.get(activeGame.DM)
    
            activeGame.DM = newDM.id
            activeGame.setDM(gamedb)
    
            return `DM successfully changed to from ${oldDM} to ${newDM}`
        } 
        // Changes currently active game to a different game
        else if(commandName === 'change-game'){
            new ActiveGame(guildID, String(gameName), '', userId, true, '', 0, 0, false, null, null).changeGame(gamedb)
    
            return `Game successfully changed to **\"${gameName}\"**`
        } 
        // Views characters within currently active game
        else if(commandName === 'view-summary'){
            if(activeGame == null){
                return 'Issue retrieving active game.'
            }
    
            let embed = Character.buildSummaryEmbed(interaction.user, 
                                                    interaction.guild, 
                                                    activeGame, 
                                                    await Character.getAllCharacters(gamedb, tableNameBase))
    
            if(embed == null){
                return 'Error finding all characters and building embed.'
            }
    
            interaction.channel?.send({embeds : [embed] });
    
            return `The characters in **\"${activeGame.gameName}\"** has been successfully viewed.`
        }  
        // Views inventory of character's entire inventory or a character's specific item
        else if(commandName == 'view-inv'){
            const chrName = UtilityFunctions.formatString(options.getString('char-name', true))
    
            const chr = await customInterp?.getCharacter(chrName)
            if(chr == null){
                return `Error finding character ${chrName}.`
            } 
    
            const itemName = UtilityFunctions.formatNullString(options.getString('item-name'))
    
            if(itemName == null){
                const chrItems = await chr.getAllChrItems(gamedb, tableNameBase)
    
                const embedBuilder = chr.buildInventoryEmbed(interaction.user, interaction.guild, chrItems)
                if(embedBuilder == null){
                    return `Error building embed.`
                }
                
                interaction.channel?.send({embeds : [embedBuilder] });
        
                return  `**${chrName}'s** inventory has been successfully viewed.`
            }else{
                if(activeGame == null){
                    return 'Issue retrieving active game.'
                }
    
                const item = await Inventory.getItem(gamedb, tableNameBase, chr.id, itemName)
    
                if(item == null){
                    return 'Error retrieving item.'
                } else if(item == false || item == true){
                    return 'Item does not exist.'
                }
    
                const embedBuilder = item.buildViewEmbed(interaction.user, interaction.guild, activeGame)
                if(embedBuilder == null){
                    return 'Error building embed.'
                }
                
                interaction.channel?.send({embeds : [embedBuilder] });
        
                return `**${chrName}'s** item **${itemName}** has been successfully viewed.`
            }
        }
        // Updates quantity of an item within a character's inventory
        else if(commandName === 'modify-inv'){
            const chrName = UtilityFunctions.formatString(options.getString('char-name', true))

            const chr = await customInterp?.getCharacter(chrName)
            if(chr == null){
                return `Error finding character ${chrName}.`
            } 

            const item = UtilityFunctions.formatString(options.getString('item-name', true))
            const quant = options.getNumber('quantity')
            const desc = UtilityFunctions.formatNullString(options.getString('description'))
            const weight = options.getNumber('weight')

            const inv = await Inventory.getItem(gamedb, tableNameBase, chr.id, item)

            if(inv == null){
                return `Error retrieving item ${item} in inventory for ${chrName}.`
            } 

            //If doesn't exist, then add new item to inventory
            //If does exist, change quantity (Remove if quantity results in less than 0)

            if(inv == false || inv == true){
                let newChrInv = new Inventory(chr.id, item, quant, desc, weight)

                if(newChrInv.quantity <= 0){
                    return `Error: Cannot add item ${item} with nonpositive quantity (${quant}).`
                }

                newChrInv.addToTable(gamedb, tableNameBase)

                return `Character **${chrName}'s** inventory has been successfully updated to add 
                        **${newChrInv.quantity}** of **\"${item}\"**.`
            } else{
                const newQuant = inv.quantity + (quant == null ? 1 : quant);

                if(newQuant <= 0){
                    inv.removeFromTable(gamedb, tableNameBase)

                    return `Character **${chrName}'s** inventory has been successfully updated to remove 
                            item **\"${item}\"**.`
                }else{
                    inv.updateItem(gamedb, tableNameBase, newQuant, weight, desc)

                    return `Character **${chrName}\'s** inventory has been successfully updated to possess 
                            **${newQuant}** of **\"${item}\"**.`
                }
            }
        }

        else if(commandName === 'init'){
            const action = options.getString('action', true).toUpperCase()
            let hideHP = options.getBoolean('hide-hp')
            hideHP ??= false
            const startConds = ['B', 'BEGIN', 'S', 'START']
            const endConds =['E', 'END']
            const nextConds =['N', 'NEXT']

            if(activeGame == null){
                return 'Issue retrieving active game.'
            }

            if(startConds.includes(action)){
                if(activeGame.messageID != null){
                    return 'Cannot start initiative as there is already one in progress.'
                    + ' Please end other initiative before starting a new one.'
                }

                let roll = options.getString('roll')
                roll ??= '1d20'

                Initiative.createTable(gamedb, tableNameBase)
                const msg = await interaction.channel?.send(
                    await Initiative.buildInitMsg(gamedb, tableNameBase, activeGame))

                msg?.pin()

                if(msg == undefined){
                    return 'Error sending initiative message.'
                }

                activeGame.updateInit(gamedb, msg.channel.id, msg.id, roll, 0, 0, hideHP)

                return '**Initative Begins !**'
            } else if(endConds.includes(action)){
                if(activeGame.messageID == null){
                    return 'Cannot start initiative as there is none in progress.'
                }
                
                Initiative.dropTable(gamedb, tableNameBase)

                if(activeGame.channelID != null && activeGame.messageID != null){
                    let message = await UtilityFunctions.getMessage(client, 
                                                                    guildID, 
                                                                    activeGame.channelID, 
                                                                    activeGame.messageID)
                    message?.unpin()

                    activeGame.updateInit(gamedb, null, null, '1d20', 0, 0, hideHP)
                
                    return `**Initative Summary**\n*Rounds:* ${activeGame.round}\n*Turns:* ${activeGame.turn}`
                            + `\n${message?.content == undefined ? '' : message.content }`
                }  

                return 'Error Finding ChannelID and/or MessageID'
            } else if(nextConds.includes(action)){
                if(activeGame.messageID == null){
                    return 'Error: No initative in progress.'
                }

                let nextInit = await Initiative.nextTurn(gamedb, tableNameBase, activeGame)

                if(nextInit == undefined){
                    return 'Issue proceeding to next turn.'
                }

                if(activeGame.channelID != null){
                    let message = await UtilityFunctions.getMessage(client, 
                                                                    guildID, 
                                                                    activeGame.channelID, 
                                                                    activeGame.messageID)
                    message?.edit(await Initiative.buildInitMsg(gamedb, tableNameBase, activeGame))
                }  
                
                const guild = client.guilds.cache.get(guildID)
                const displayUser = guild?.members.cache.get(String(nextInit?.user))

                return `${nextInit?.emote == undefined ? '' : UtilityFunctions.getEmoteDisplay(interaction.guild, nextInit.emote)}`
                          + `${displayUser} (Round ${activeGame.round}, Turn ${activeGame.turn}) **${nextInit?.name}'s** Turn!`
            }
            else{
                return 'Error: Invalid action.'
            }
        }

        else if(commandName === 'init-add'){
            if(activeGame == null){
                return 'Issue retrieving active game.'
            }

            if(activeGame.messageID == null){
                return 'Cannot add character to initiative as there is none in progress.'
            }

            let chrName = UtilityFunctions.formatString(options.getString('char-name', true))
            let emote = UtilityFunctions.getEmojiID(
                            UtilityFunctions.formatString(options.getString('emote'))
                        )
            let hp = options.getNumber('hp')

            const chr = await customInterp?.getCharacter(chrName)
            let dmg = 0
            if(hp == null && chr != null){
                hp = chr.health
                dmg = chr.dmgTaken
            }

            if(emote == null && chr != null){
                emote = chr.emote
            }

            let quantity = options.getNumber('quantity')

            quantity ??= 1

            let replyStr = ''

            for(let chrInd = 0; chrInd < quantity; ++chrInd){
                let name = quantity == 1 ? chrName : `${chrName} ${chrInd + 1}` //TODO: Figure out a better way to do this
                const query = options.getString('query')

                const result = UtilityFunctions.parseRoll(query == null ? activeGame.defaultRoll : query)
    
                if(result == undefined){
                    return 'Error parsing roll.'
                }
    
                if(!(await new Initiative(name, result[1], false, dmg, hp, userId, emote).addToTable(gamedb, tableNameBase))){
                    return 'Error: Character is already in initiative.'
                }
    
                if(activeGame.channelID != null){
                    let message = await UtilityFunctions.getMessage(client, 
                                                                    guildID, 
                                                                    activeGame.channelID, 
                                                                    activeGame.messageID)
                    message?.edit(await Initiative.buildInitMsg(gamedb, tableNameBase, activeGame))
                    
                    replyStr += `Character **\"${name}\"** added to initiative: ${result[0]} = __*${result[1]}*__\n`
                }  
            } 

            return replyStr
            //return 'Issue adding character(s) to initiative.'
        }

        else if(commandName === 'init-rmv'){
            if(activeGame == null){
                return 'Issue retrieving active game.'
            }

            if(activeGame.messageID == null){
                return 'Cannot remove character from initiative as there is none in progress.'
            }

            const chrName = UtilityFunctions.formatString(options.getString('char-name', true))

            /*const chr = await customInterp?.getCharacter(chrName)
            if(chr == null){
                return `Error finding character ${chrName}.`
            } */

            new Initiative(chrName, -1, false, 0, 0, userId, '').removeFromTable(gamedb, tableNameBase)

            if(activeGame.channelID != null){
                let message = await UtilityFunctions.getMessage(client, 
                                                                guildID, 
                                                                activeGame.channelID, 
                                                                activeGame.messageID)
                message?.edit(await Initiative.buildInitMsg(gamedb, tableNameBase, activeGame))

                return `**\"${chrName}\"** successfully removed from initiative.`
            }   

            return 'Issue removing character from initiative.'
        }

        else if(commandName === 'hp'){

            const chrName = UtilityFunctions.formatString(options.getString('char-name', true))
            const value = options.getNumber('value', true)
            let initOnly = options.getBoolean('init-only')

            initOnly ??= false

            const chr = await customInterp?.getCharacter(chrName)
            let replyStr = ''
            const isChrFindable = !initOnly && chr != null && chr != undefined

            if(isChrFindable){
                chr.updateDMG(gamedb, tableNameBase, value)
                replyStr += 'Character '
            }

            const initChr = await Initiative.getInitChr(gamedb, tableNameBase, chrName)

            if(initChr != null && initChr.HP != null){
                if(activeGame == null){
                    return 'Issue retrieving active game.'
                }

                initChr.updateDMG(gamedb, tableNameBase, value)
                replyStr += isChrFindable ? '& ' : ''
                replyStr += 'Initiative '

                if(activeGame.channelID != null && activeGame.messageID != null){
                    let message = await UtilityFunctions.getMessage(client, 
                                                                    guildID, 
                                                                    activeGame.channelID, 
                                                                    activeGame.messageID)
                    message?.edit(await Initiative.buildInitMsg(gamedb, tableNameBase, activeGame))
                }
            }

            return replyStr === '' ? 'Error: Character & Initiative not found' : `${replyStr}for **\"${chrName}\"** updated.` 
        }

        // Calls custom interpreter if command is not within base commands
        const retVal = customInterp?.interpret(commandName, options, activeGame, interaction) 
        return retVal == undefined ? 'Command Not Found.' : retVal
    }
    
}

export{CommandInterpreter}