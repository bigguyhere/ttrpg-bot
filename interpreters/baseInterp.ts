import { Client, CacheType, ChatInputCommandInteraction, ChannelType, TextBasedChannel} from "discord.js"
import { Connection } from "mysql"
import { SelectInterpreter } from "./select_interpreter"
import { ActiveGame } from "../models/activegame"
import { Character } from "../models/character"
import { Initiative } from "../models/initiative"
import { Inventory } from "../models/inventory"
import { UtilityFunctions }  from '../utility/general'
import { GameInterpreter } from "./std_interpreters/gameInterp"
import { CharacterInterpreter } from "./std_interpreters/charInterp"
import { InventoryInterpreter } from "./std_interpreters/invInterp"
import { InitInterpreter } from "./std_interpreters/initInterp"

module CommandInterpreter{
    /**
     * Replies with return of interpretHelper to original slash command
     * @param interaction - Interaction to be passed to interpretHelper
     * @param gamedb - Database connection to be passed to interpretHelper
     * @param guildID - GuildID (Server ID) to be passed to interpretHelper
     * @param client - Discord Client to be passed to interpretHelper
     */
    export async function interpret(interaction: ChatInputCommandInteraction<CacheType>,
                                            gamedb: Connection,
                                            guildID: string,
                                            client: Client<boolean>) : Promise<void> {
        interaction.reply({
            content: await interpretHelper(interaction, gamedb, guildID, client)
        })
    }

    /**
     * Interprets slash commands for characters, games, rolls, and items
     * @param interaction - Interaction generated by user's initial slash command
     * @param gamedb - Database connection where game data is stored
     * @param guildID - Current Discord Server ID
     * @param client - Discord Client generated for current instances
     */
    export async function interpretHelper(interaction: ChatInputCommandInteraction<CacheType>, 
                                            gamedb: Connection,
                                            guildID: string,
                                            client: Client<boolean>) : Promise<string> {
        ActiveGame.createTable(gamedb)
    
        const { commandName, options } = interaction
        const subcommandName = options.getSubcommand()

        const gameName = UtilityFunctions.formatNullString(options.getString('game-name'), / /g, '_')
        
        const activeGame = await ActiveGame.getCurrentGame(gamedb, 'GamesDB', guildID, gameName)
        const tableNameBase = `${guildID}_${activeGame?.gameName == null? gameName : activeGame?.gameName}`;
        const customInterp = SelectInterpreter.select(activeGame?.gameType, gamedb, tableNameBase)

        console.log(commandName)

        if(commandName === 'game') {
            const gameInterpreter = new GameInterpreter(gamedb, tableNameBase, options, interaction, guildID)
            switch (subcommandName){
                case ('create'):
                    return gameInterpreter.createGame()
                case ('change'):
                    return gameInterpreter.changeGame()
                case ('set-dm'):
                    if(activeGame == null){
                        return 'Issue retrieving active game.'
                    }
                    return gameInterpreter.changeDM(activeGame, client)
                case ('view-summary'):
                    if(activeGame == null){
                        return 'Issue retrieving active game.'
                    }
                    return await gameInterpreter.viewSummary(activeGame)
            }
        } 
        else if(commandName === 'character') {
            const chrInterpreter = new CharacterInterpreter(gamedb, tableNameBase, options, interaction)
            switch (subcommandName){
                case ('add'):
                    return await chrInterpreter.add()
                case ('remove'):
                    return await chrInterpreter.remove(customInterp)
                case ('view'):
                    return await chrInterpreter.view(customInterp)
                case ('change-stat'):
                    return chrInterpreter.changeStat()
            }
        }
        else if(commandName === 'roll') {
            const query = options.getString('query', true)
            let identifier = options.getString('identifier')

            identifier ??= 'Result'
            identifier += ': '
    
            const result = UtilityFunctions.parseRoll(query)
            
            return `${interaction.user} :game_die:\n**${identifier}** ${result?.[0]}\n**Total:** ${result?.[1]}`
        }
        else if(commandName === 'inventory') {
            const invInterpreter = new InventoryInterpreter(gamedb, tableNameBase, options, interaction)
            switch (subcommandName){
                case ('modify'):
                    return await invInterpreter.modify(customInterp)
                case ('view'):
                    if(activeGame == null){
                        return 'Issue retrieving active game.'
                    }
                    return await invInterpreter.view(customInterp, activeGame)
            }
        }
        else if (commandName === 'initiative') {
            const initInterpreter = new InitInterpreter(gamedb, tableNameBase, options, interaction, guildID)

            if(activeGame == null){
                return 'Issue retrieving active game.'
            }

            switch (subcommandName){
                if(activeGame == null){
                    return 'Issue retrieving active game.'
                }
                case ('begin'):
                    return await initInterpreter.begin(activeGame)
                case ('end'):
                    return await initInterpreter.end(activeGame)
                case('next'):
                    return await initInterpreter.next(activeGame, client)
                case('add'):
                    return await initInterpreter.addCharacter(activeGame, customInterp)
                case('remove'):
                    return await initInterpreter.removeCharacter(activeGame)
                case('active'):
                    return await initInterpreter.setActiveChar(activeGame)
                case('hp'):
                    return await initInterpreter.changeHP(activeGame, customInterp)
            }
        }

        // Calls custom interpreter if command is not within base commands
        const retVal = customInterp?.interpret(commandName, options, activeGame, interaction) 
        return retVal == undefined ? 'Command Not Found.' : retVal
    }
    
}

export{CommandInterpreter}